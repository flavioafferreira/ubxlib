# Introdução
Isso pretende conselhos -chave/conciso para aqueles ativos no desenvolvimento de `ubxlib` e é colocado aqui para que não possa ser perdido.

# Tudo que importa
`Ubxlib` existe para que o U-Blox seja capaz de vender mais módulos em mais aplicativos, facilitando a integração de um cliente aos módulos U-Blox atuais e futuros; é isso. `ubxlib` não tem significado/valor de si mesmo, é apenas um meio para esse fim. Pense assim e você se comportará da maneira certa. 

 # Seja a cauda 
 Há uma frase em inglês "A cauda abanando o cachorro", usada para descrever situações em que algo menos importante acabou controlando algo um pouco mais importante. `Ubxlib` é a cauda: um driver para apenas um ou dois componentes em um aplicativo de clientes, ele deve dobrar/flexionar o aplicativo do cliente exigir, não deve colocar os requisitos ou limitar o aplicativo dos clientes, se possível. Exemplos incluem:
- Todos `#definem que um cliente pode precisar modificar deve ser construído como`#ifndef/#define/#endif` para que o cliente possa modificar o valor sem modificar o código, 
 - As funções não devem levar mais de alguns 10 segundos para executar, pior caso, caso contrário, a função deve incluir um parâmetro `bool keeppallCallback ()` que o cliente pode usar para alimentar um cronômetro de vigilância ou desistir dessa operação se o aplicativo não é mais capaz de bloquear, 
 - Obviamente, o código-fonte completo e razoavelmente complicado está sempre disponível; No final, um cliente sempre pode fazer o que deseja. 

 # APIs são rei 
 Seu código é irrelevante, sua API é o que importa. Ao construir uma nova API, escreva os cabeçalhos da função da API, documente-os no arquivo `.h` de uma maneira amigável para doxygen (dica: ler a saída de doxygen geralmente fornece uma perspectiva útil sobre o que você alcançou), pense na API's Comportamento dinâmico da perspectiva de um aplicativo (isto é, aquele que não tem o contexto do mundo do módulo), talvez junte o todo com as funções que apenas retornando `u_error_common_not_implemented` (então nenhuma implementação ainda conhecido por ser feliz) e enviar um PR que possa ser revisado ** apenas do ponto de vista da API **; Não se fundir esse PR, basta usá -lo como um mecanismo de revisão. Somente quando você e seus colegas estão satisfeitos com a API, há algum ponto na implementação inicial. 

 Aliás, isso também se aplica aos assuntos de configuração/automação: escreva o documento que descreve a coisa e apenas _ então faça a coisa; Dessa forma, outra pessoa, ou você em um mês, poderá replicá -lo. 

 Outra maneira igualmente importante pela qual uma API pública é o rei é que as APIs públicas (ou seja, qualquer coisa em um arquivo `API/*. H`) não deve mudar, em termos de sua forma e, mais insidiosamente, em termos de seu comportamento dinâmico ; Isso quebraria o aplicativo dos clientes e o cliente simplesmente iria para outro lugar ou se ramificará e não poderá facilmente tirar proveito dos novos/futuros módulos U-Blox, se você fazê-lo com muita frequência. Se, por qualquer motivo, for necessário quebrar uma API, anunciar isso com antecedência, depreciando o antigo e introduzindo o novo com alguns meses de lacuna e inclua as palavras "quebrando" nas capitais no início da mensagem de confirmação que causa o Breakage para que o commit se destaque na história do compromisso. 

 # Seu código não importa 
 A única maneira de criar software que durará, pode ser mantida, é sufocá -lo em testes totalmente automatizados. Depois de ter uma boa API com boa cobertura de teste, a _Mplementation_ das APIs é irrelevante; Tem que estar lá, mas não é o que importa, o que importa é que a API atenda aos testes. Um _ pode escrever os testes antes do código abaixo das APIs, no entanto, uma vez que `ubxlib` é uma camada fina entre o aplicativo e a interface AT/UBX do módulo, é provável que o processo de escrever o código tenha um feedback Efeito na forma das próprias APIs à medida que o comportamento do módulo se torna aparente, as "escalas cairão dos seus olhos"; portanto, menos resulta em retrabalho se você escrever o código e depois acompanhar a gravação dos testes. Todo o código para uma nova API deve incluir testes automatizados, de modo que um revisor possa revisar a API e os testes, na verdade não tem _s para revisar o código (embora obviamente isso seja desejável/natural).# Test Automation Leads To Speed
Os testes devem ser tais que seja executado de maneira confiável/automaticamente em todos os esforços para este repositório. Isso permite que você se mova rapidamente: escreva algum código, se for uma nova API, escreva um teste, comprometa e pressione para uma filial desse repositório e o teste deve ser executado automaticamente, sem que você precise fazer nada; Um resultado verde, ou um resultado vermelho por razões fora do seu controle, razões que você pode justificar em um comentário contra um PR (testamos de ponta a ponta e, portanto, pode sempre haver coisas intermitentes que causarão um resultado vermelho) permitirá que você prossiga com segurança. Qualquer fenda nessa armadura _wayways_vará você mais tarde e, com uma grande base de código, você pode achar muito difícil recuperar. 

 # Sempre deve ser possível empurrar para o público `master ' 
 Deve sempre ser possível, a qualquer momento, empurrar o ramo `master` do 'ubxlib_priv` repo para o ramo' master` do público 'ubxlib` repo; A parede da defesa do teste automatizado em todos os relações públicas torna isso possível. Se você tiver uma alteração que pode quebrar uma API pública, ou você criou uma nova API e deseja tempo para resolvê -la antes de publicar, pegue seu código por meio de um PR para o ramo `Development`, e apenas mescla` desenvolvimento `Abaixo até` master` quando você está feliz que tudo no `` desenvolvimento 'possa ser tornado público; Os PRs para `desenvolvimento` são protegidos pela mesma parede de teste automatizado e, portanto, a qualidade é mantida. Como um aparte, apenas uma 'mesclagem' de 'desenvolvimento' em 'Master`, ou de' Master 'no' Development` deve 'Development` precisar de uma atualização; Nunca 'Rebase` ou' Force-Push`, pois isso fará com que a história seja reescrita e quebre a compatibilidade com qualquer outra pessoa que trabalha na linha de código além do ponto em que você acabou de vaporizar, incluindo o cliente. 

 # Evite dependências de tempo de compilação em `ubxlib` 
 Deve ser possível que o aplicativo de um cliente modifique qualquer coisa que você pretenda ser modificável ao cliente, chamando uma função API `ubxlib`; pinos para o que quer que seja, tempos limites, etc. Agora, obviamente, isso não será universalmente verdadeiro: por exemplo Em alguns casos, pode haver tempo de tempo fixo feito através de uma construção `##ifndef/#define/#endif`, mas o objetivo deve ser que possamos, se desejarmos, criarmos uma biblioteca pré-compilada de` ubxlib` e seria como utilizável pelo cliente. Isso maximiza a flexibilidade, tanto para o cliente quanto para nós, e, igualmente importante, possibilita um rápido teste automatizado, pois um único binário pode ser mantido e usado para todos os testes. 

 Da mesma forma, a compilação condicional geralmente deve ser evitada no código do núcleo `ubxlib`: leva a pontos mortos, cantos que os testes não cobrirão; É bom, muitas vezes inevitável, usar a compilação condicional no código _test_, mas não no código principal, o material abaixo de uma API.# Documento para o próximo mês 
 Comente seu código como se você estivesse conversando consigo mesmo no próximo mês, quando se mudou para outra coisa, teve o fim de semana de folga, talvez tomasse algumas bebidas e perdeu inteiramente o contexto/cache que você já teve. Por que você tirou um de X, ignorou um valor de retorno, fez algo fora do comum, o que for, não será mais óbvio; Você precisa dizer por que fez isso explicitamente. 

 E não tenha medo de adicionar comentários no estilo "história" que guiam o leitor pelo caminho do código de maneira legível pelo homem sem que eles tenham que analisar cada linha como um compilador: você não é um compilador, seja gentil para Seu futuro eu (e o cliente). 

 # Suas mensagens de confirmação são nossa única documentação de mudança 
 Semelhante a comentar, é fácil ao escrever uma mensagem de confirmação para esquecer que a leitura de que não tem absolutamente seu contexto. Uma primeira linha de "contagem de tentativa de correção" é claramente inútil, mas "Fix HTTP Rent Count" é quase tão inútil se for a alteração, digamos, apenas para celular. Algo como "Correção celular apenas para HTTP: aumentar a contagem de repetições" daria o contexto correto: é uma alteração `célula ', então aqueles que apenas usam` ubxlib` para `wifi' podem ignorá -la (se for uma alteração 'célula' Somente para Lara-R6, então diga isso e o número de pessoas preocupadas é reduzido ainda mais), é apenas para a API `http`, para que os usuários do MQTT possam ignorá-lo e a contagem está subindo. 

 Então, no corpo da mensagem de confirmação, não tenha medo de dizer por que, de uma maneira detalhada/legível, a mudança é justificada; Essas mensagens de comprometimento são visíveis publicamente e a única documentação de mudança que colocamos de volta nela. Observe que, para uma única confirmação, uma mesclagem `squash` no Github oferece a oportunidade de refinar/re-palavras a mensagem de confirmação no último minuto ao mesclar o PR aprovado. 

 Um corolário disso é que você deve tentar não combinar mudanças díspares em um único compromisso; Comprometes discretos são mais fáceis para o cliente absorver.